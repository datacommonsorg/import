package org.datacommons.util;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import java.awt.*;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import org.datacommons.proto.Debug;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.AxisSpace;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.graphics2d.svg.SVGGraphics2D;

public class SummaryReportGenerator {

  public static boolean TEST_mode = false;
  public static final String SUMMARY_REPORT_HTML = "summary_report.html";

  // An object to save the information about a stat var. This contains all the necessary getters to
  // access the information in this object from SummaryReport.ftl
  // TODO(chejennifer): Look into a cleaner way to handle information about a stat var
  public static final class StatVarSummary {
    private static final int CHART_WIDTH = 500;
    private static final int CHART_HEIGHT = 250;

    int numObservations = 0;
    Set<String> places = new HashSet<>();
    Set<String> mMethods = new HashSet<>();
    Set<String> units = new HashSet<>();
    Set<String> scalingFactors = new HashSet<>();
    Set<String> valueTypes = new HashSet<>();
    Set<String> observationPeriods = new HashSet<>();
    // This set will not be populated when StatVarSummary is generated by PlaceSeriesSummary
    Set<String> dates = new HashSet<>();

    // The following two lists will only be populated for StatVarSummary generated by
    // PlaceSeriesSummary and the value at index n of seriesValues will correspond to the date at
    // index n of seriesDates.
    List<String> seriesDates = new ArrayList<>();
    List<String> seriesValues = new ArrayList<>();

    public int getNumObservations() {
      return this.numObservations;
    }

    public Set<String> getPlaces() {
      return new TreeSet<>(this.places);
    }

    public Set<String> getValueTypes() {
      return new TreeSet<>(this.valueTypes);
    }

    public Set<String> getMMethods() {
      return new TreeSet<>(this.mMethods);
    }

    public Set<String> getUnits() {
      return new TreeSet<>(this.units);
    }

    public Set<String> getSFactors() {
      return new TreeSet<>(this.scalingFactors);
    }

    public Set<String> getObservationPeriods() {
      return new TreeSet<>(this.observationPeriods);
    }

    public Set<String> getUniqueDates() {
      return new TreeSet<>(this.dates);
    }

    public List<String> getSeriesDates() {
      return this.seriesDates;
    }

    public List<String> getSeriesValues() {
      return this.seriesValues;
    }

    public static String constructSVGChartFromTimeSeries(TimeSeries timeSeries) {
      TimeSeriesCollection dataset = new TimeSeriesCollection();
      if (timeSeries.isEmpty()) return "";
      dataset.addSeries(timeSeries);
      // create the time series chart with default settings
      JFreeChart chart = ChartFactory.createTimeSeriesChart("", "", "", null);
      XYPlot plot = chart.getXYPlot();
      // create and use separate renderers for the line and the shapes to be able
      // to customize their colors. we use the same dataset on each so that they have
      // the same outline.
      XYItemRenderer lineRenderer = new XYLineAndShapeRenderer(true, false);
      XYItemRenderer shapeRenderer = new XYLineAndShapeRenderer(false, true);
      lineRenderer.setSeriesPaint(0, Color.BLACK); // new Color(0x00, 0x00, 0xff));
      shapeRenderer.setSeriesPaint(0, Color.RED); // new Color(0x00, 0x00, 0xff));

      // shapeOffset is both in X and Y. 0 origin is anchored on the top-left of the shape
      // for Ellipse2D.Double, but the center of the shape for XYItemRenderer, so we offset
      // the Ellipse2D.Double shape to place it where it needs to be.
      double shapeSize = 4; // we may put this in a CLI flag if desired.
      double shapeOffset = -1.0 * (shapeSize / 2.0);
      lineRenderer.setSeriesShape(
          0, new Ellipse2D.Double(shapeOffset, shapeOffset, shapeSize, shapeSize));
      shapeRenderer.setSeriesShape(
          0, new Ellipse2D.Double(shapeOffset, shapeOffset, shapeSize, shapeSize));

      lineRenderer.setSeriesVisibleInLegend(0, false);
      shapeRenderer.setSeriesVisibleInLegend(0, false);

      // lower indices are painted over higher indices
      // this makes it such that the dots are over the lines, making them clear.
      plot.setRenderer(0, shapeRenderer);
      plot.setRenderer(1, lineRenderer);

      plot.setDataset(0, dataset);
      plot.setDataset(1, dataset);

      plot.setBackgroundPaint(Color.WHITE);
      ValueAxis yAxis = plot.getRangeAxis();
      if (timeSeries.findValueRange().getLength() == 0) {
        // Manually set the range when the values in the time series are all the same. Otherwise,
        // the chart library will draw an axis with multiple ticks all labeled with that same value.
        double singleValue = timeSeries.getValue(0).doubleValue();
        yAxis.setRange(singleValue - 1, singleValue + 1);
      }
      DateAxis xAxis = (DateAxis) plot.getDomainAxis();
      if (timeSeries.getTimePeriods().size() == 1) {
        // Override the date formatter for the x-axis when there is only one data point. Otherwise,
        // the chart library will label the single date as 00:00:00.
        String datePattern =
            StringUtil.getValidISO8601DatePattern(
                timeSeries.getTimePeriods().iterator().next().toString());
        if (StringUtil.getValidISO8601DateTemplate(datePattern).isEmpty()) {
          xAxis.setDateFormatOverride(new SimpleDateFormat("yyyy-MM-dd"));
        } else {
          xAxis.setDateFormatOverride(new SimpleDateFormat(datePattern));
        }
      }
      SVGGraphics2D svg = new SVGGraphics2D(CHART_WIDTH, CHART_HEIGHT);
      if (TEST_mode) {
        // When testing, we want the svg clipPath id to be consistent.
        svg.setDefsKeyPrefix("test");
        // When testing, We want to keep the font of the labels consistent.
        Font tickLabelFont = new Font("SansSerif", 0, 10);
        yAxis.setTickLabelFont(tickLabelFont);
        xAxis.setTickLabelFont(tickLabelFont);
        // When testing, we want to keep the sizes of the legends and data area consistent.
        AxisSpace xAxisSpace = new AxisSpace();
        xAxisSpace.setBottom(15);
        plot.setFixedDomainAxisSpace(xAxisSpace);
        AxisSpace yAxisSpace = new AxisSpace();
        yAxisSpace.setLeft(40);
        plot.setFixedRangeAxisSpace(yAxisSpace);
      }
      // draw the chart on the svg
      chart.draw(svg, new Rectangle2D.Double(0, 0, CHART_WIDTH, CHART_HEIGHT));
      return svg.getSVGElement();
    }
  }

  public static void generateReportSummary(
      Path outputDir,
      Debug.Log log,
      Map<String, StatVarSummary> svSummaryMap,
      Map<String, PlaceSeriesSummary> placeSeriesSummaryMap)
      throws IOException, TemplateException {
    Configuration cfg = getConfiguration();
    Template template = cfg.getTemplate("SummaryReport.ftl");
    HashMap<String, Object> data = new HashMap<>();
    data.put("levelSummary", log.getLevelSummaryMap());
    data.put("commandArgs", log.getCommandArgs());
    // When testing, we want the order of the sections in the html file to be deterministic
    if (TEST_mode) {
      svSummaryMap = new TreeMap<>(svSummaryMap);
      placeSeriesSummaryMap = new TreeMap<>(placeSeriesSummaryMap);
      PlaceSeriesSummary.TEST_mode = true;
    }
    data.put("svSummaryMap", svSummaryMap);
    data.put("placeSeriesSummaryMap", placeSeriesSummaryMap);
    Writer file = new FileWriter(Paths.get(outputDir.toString(), SUMMARY_REPORT_HTML).toString());
    template.process(data, file);
  }

  private static Configuration getConfiguration() throws IOException {
    Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
    cfg.setDefaultEncoding("UTF-8");
    cfg.setLocale(Locale.US);
    cfg.setClassForTemplateLoading(SummaryReportGenerator.class, "/");
    return cfg;
  }
}
